# simter-file Rest API

The rest context-path could be configured by property `simter-file.rest-context-path`.
Its default value is `/file`. The below URL use the default context-path value.

Provide rest APIs:

|    | Method | Url                                            | Description
|----|--------|------------------------------------------------|-------------
| 1  | POST   | /file?module=x&name=x&type=x&input-name=x      | Upload file
| 2  | PATCH  | /file/$id?module=x&name=x&type=x&input-name=x  | Update exists file
| 3  | DELETE | /file/$id?module                               | Delete file
| 4  | GET    | /file/$id?type=x&filename=x&inline&pack        | Download file
| 5  | GET    | /file?pageable&offset=&limit=&module=$search=  | Find file-view data

**$FILE:**

| Name     | Description
|----------|-------------
| id       | file identity with default format `${yyyyMMddTHHmmssSSSS}-${uuid6Prefix}`
| module   | business module identity
| name     | file name without extension
| type     | file extension 
| size     | file size
| path     | physical file store path relative to app base dir.
| createOn | created datetime with ISO format `yyyy-MM-ddTHH:mm:ss.S+Z`
| creator  | file upload user
| modifyOn | last modified datetime with ISO format `yyyy-MM-ddTHH:mm:ss.S+Z`
| modifier | file last modified user

## 1. Upload file

**Request:**

```
POST /file?module=x&name=x&type=x&input-name=
Content-Type: $contentType
Content-Length: $len

$fileDate
```

| Name        | Require | Description
|-------------|---------|-------------
| module      | false   | business module identity, default value is '/default/', must url-encoded, starts and ends with '/' 
| name        | false   | file name without extension, default value is 'unknown'
| type        | false   | file extension, default value is 'xyz'
| len         | true    | request body size with byte unit
| contentType | true    | support two value: <br>1. `application/octet-stream` for ajax upload<br>2. `multipart/form-data` for traditional form submit
| input-name  | false   | only for traditional form submit, custom the `<input type=file name=file>` name attribute value, default 'file'

**Response:**

```
201 Created
Content-Type: text/plain

$id
```

> The id in response body is auto generated by backend.

### 1.1. Upload by ajax

With request Content-Type `application/octet-stream`.
The request body contains all the file binary data.

### 1.2. Upload by traditional form submit

With request Content-Type `multipart/form-data`.
The request body contains all the form submit data.

Use a traditional `'<input type="file" name="$inputName">'` way to submit a form.

**Request Sample:**

```
POST /?module=x&name=x&type=x&input-name=
Content-Type        : multipart/form-data; boundary=----$boundary
Content-Length      : $len

------$boundary
Content-Disposition: form-data; name="$inputName"; filename="$filename"
Content-Type: application/octet-stream # should be the real file media type, such as image/png

$fileData
------$boundary----
```

| Name       | Require | Description
|------------|---------|-------------
| boundary   | true    | random boundary value generated by client
| len        | true    | request body size with byte unit
| input-name | false   | custom input element name, default "file"
| inputName  | true    | input element name, must equals with the `input-name` query param value
| filename   | true    | client original file name with extension but without any client file path
| fileData   | true    | file binary data

## 2. Update exists file

**Request:**

```
PATCH /file/id?module=x&name=x&type=x&input-name=
Content-Type: $contentType
Content-Length: $len

$fileDate
```

| Name        | Require | Description
|-------------|---------|-------------
| module      | false   | business module identity, must url-encoded, starts and ends with '/'
| name        | false   | file name without extension
| type        | false   | file extension
| len         | true    | request body size with byte unit
| contentType | false   | support two value: <br>1. `application/octet-stream` for ajax upload<br>2. `multipart/form-data` for traditional form submit
| input-name  | false   | only for traditional form submit, custom the `<input type=file name=file>` name attribute value, default 'file'

**Response:**

```
204 NoContent
```

If the attachment does not exist, the response returns:

```
404 Not Found
Content-Type : plain/text

no file to update was foundÔºÅ
```

### 1.1. Update by ajax

With request Content-Type `application/octet-stream`.
The request body contains all the file binary data.

### 1.2. Update by traditional form submit

With request Content-Type `multipart/form-data`.
The request body contains all the form submit data.

Use a traditional `'<input type="file" name="$inputName">'` way to submit a form.

## 3. Delete file

**Request:**

```
DELETE /file/$id?module
```

| Name        | Require | Description
|-------------|---------|-------------
| id          | true    | file id or module depends on whether has 'module' query param, multiple file ids can be concatenated with ','
| module      | false   | specify this query param means $id is a url-encode module value

> If specify module query param, $id value ends with '/' means equation-module strategy, 
> ends with '/%' means starts-with-module strategy

**Response:**

```
200 OK
Content-Type: text/plain

$deletedCount
```

> If no match files deleted, $deletedCount = 0.

## 4. Download file

**Request:**

```
GET /file/$id?type=x&filename=x&inline&pack
```

| Name        | Require | Description
|-------------|---------|-------------
| id          | false   | file id, path or module depends on the 'type' query param value 
| filename    | false   | file name with extension, default '$name.$type'
| len         | true    | request body size with byte unit
| contentType | true    | support two value: <br>1. `multipart/form-data` for traditional form submit<br>2. other real media type like `application/octet-stream`, `image/png` for ajax upload with file binary data
| input-name  | false   | only for traditional form submit, custom the `<input type=file name=file>` name attribute value, default 'file'
| type        | false   | specify the id type, see below, default means $id is a file id
| inline      | false   | specify `Content-Disposition=inline; filename="..."`, default `attachment`
| pack        | false   | whether pack to zip file and then download it
| mapper      | false   | when need pack, use this to map the zip file entry folder name.<br>- String value for simple mapper<br>- JsonObject String for complex mapper

**Support 'type' value:**

| Value  | Description
|--------|-------------
| -      | missing 'type' query param means $id is a really file id
| module | means $id is business module identity, must url-encoded, starts and ends with '/'
| path   | means $id is a file path value, must url-encoded, this way is high performance way because backend directly download this path file and no need to query it from database first

> The module value has two match strategy. Default is equation strategy. 
> Another is starts-with strategy if value ends with '/%'.

**URL sample for download specific file id:**

| Name            | Description
|-----------------|-------------
| GET /$id        | download origin file with header `Content-Disposition=attachment; filename="$name.$type"`
| GET /$id?inline | download origin file with header `Content-Disposition=inline; filename="$name.$type"`
| GET /$id?pack   | compress and download origin file with zip format and `filename=$name.$type.zip`

> If want to download multiple ids, just use ',' to concat them. if has multiple ids, 
> they will be compressed and download with file name '$filename' and always has a '.zip' extension.
> Fallback to use 'unknown.zip' if missing 'filename' query param.

**URL sample for download specific file path:**

| Name                        |
|-----------------------------|
| GET /$path?type=path        |
| GET /$path?type=path&inline |
| GET /$path?type=path&pack   |

> $path value must url-encoded

**URL sample for download specific module files:**

| Name                            |
|---------------------------------|
| GET /$module?type=module        |
| GET /$module?type=module&inline |
| GET /$module?type=module&pack   |

> $module value must url-encoded.
> Auto pack to zip file to download if more than one file match the module.
> If only one file match the module, download origin file without zip if no 'pack' query param.

**Response:** (if found)

```
200 OK
Content-Type        : application/octet-stream # should prefer to use the real file media type
Content-Length      : $len
Content-Disposition : $downloadType; filename="$filename"

$fileData
```

The `filename` value in the header `Content-Disposition` must be quoted by 
double quotation and decoded by ISO-8859-1 (RFC2183). The value of header 
`Content-Type` should prefer to use the actual MIME type of the real file 
fallback to use `application/octet-stream` instead. MIME type reference 
from [here](https://www.iana.org/assignments/media-types/media-types.xhtml).

**Response:** (if not found)

```
404 Not Found
```

## 5. Find file-view data

**Request:**

```
GET /file?pageable&offset=&limit=&module=$search=
```

| Name     | Description
|----------|-------------
| pageable | pageable query or just query all list 
| offset   | query offset position, only for pageable query
| limit    | max return items count, default 25. 0 means no limits
| $search  | fuzzy search value for file name
| module   | business module identity, default '/default/', starts with '/'. <br>Ends with '/' means equation strategy, ends with '/%' means starts-with strategy

### 5.1. Pageable query

**Response:**

```
200 OK
Content-Type : application/json

{
  rows: [$FILE, ...],
  total, limit, offset,
}
```

> `total` is the total number that match the query.

`rows` sort by `createOn` field desc.

### 5.2. None pageable query

**Response:**

```
200 OK
Content-Type : application/json

[$FILE, ...]
```

The return array sort by `createOn` field desc.